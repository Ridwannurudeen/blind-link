// ============================================================================
// Blind-Link: Integration Test Suite
// ============================================================================
// Tests the full PSI lifecycle: registry init → user registration →
// contact intersection → result decryption.
// Run with: arcium test --cluster devnet
// ============================================================================

import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { x25519 } from "@noble/curves/ed25519";
import { randomBytes } from "crypto";
import { expect } from "chai";
import {
  getArciumEnv,
  getArciumProgram,
  getArciumProgramId,
  getMXEPublicKey,
  getClusterAccAddress,
  getComputationAccAddress,
  getMXEAccAddress,
  getMempoolAccAddress,
  getExecutingPoolAccAddress,
  getCompDefAccAddress,
  getCompDefAccOffset,
  getFeePoolAccAddress,
  getClockAccAddress,
  getLookupTableAddress,
  awaitComputationFinalization,
  RescueCipher,
  deserializeLE,
} from "@arcium-hq/client";

// IDL type generated by `anchor build` — resolve after first build
// import { BlindLink } from "../target/types/blind_link";

/** Retry a transaction up to `maxRetries` times on devnet blockhash expiry */
async function withRetry<T>(fn: () => Promise<T>, maxRetries = 5): Promise<T> {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (e: any) {
      const msg = e?.message || "";
      if (attempt < maxRetries - 1 && msg.includes("Blockhash not found") || msg.includes("block height exceeded")) {
        console.log(`    Blockhash expired, retrying (${attempt + 1}/${maxRetries})...`);
        await new Promise((r) => setTimeout(r, 3000));
        continue;
      }
      throw e;
    }
  }
  throw new Error("withRetry: unreachable");
}

/** Fetch MXE public key with null guard */
async function fetchMXEKey(
  prov: anchor.AnchorProvider,
  pid: anchor.web3.PublicKey
): Promise<Uint8Array> {
  const key = await getMXEPublicKey(prov, pid);
  if (!key) throw new Error("MXE public key not available");
  return key;
}

describe("blind-link", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.BlindLink as Program;
  const arciumEnv = getArciumEnv();

  const REGISTRY_SEED = Buffer.from("blind_link_registry");
  const SIGN_PDA_SEED = Buffer.from("ArciumSignerAccount");

  let registryPda: anchor.web3.PublicKey;
  let registryBump: number;
  let signPda: anchor.web3.PublicKey;
  let mxeAccount: anchor.web3.PublicKey;
  let arciumProgramId: anchor.web3.PublicKey;
  let feePool: anchor.web3.PublicKey;
  let clockAccount: anchor.web3.PublicKey;

  // ── Setup ───────────────────────────────────────────────────────────

  before(async () => {
    [registryPda, registryBump] =
      anchor.web3.PublicKey.findProgramAddressSync(
        [REGISTRY_SEED],
        program.programId
      );
    [signPda] = anchor.web3.PublicKey.findProgramAddressSync(
      [SIGN_PDA_SEED],
      program.programId
    );
    mxeAccount = getMXEAccAddress(program.programId);
    arciumProgramId = getArciumProgramId();
    feePool = getFeePoolAccAddress();
    clockAccount = getClockAccAddress();
  });

  // ── Test: Initialize Registry ─────────────────────────────────────

  it("initializes the global registry", async () => {
    // Skip if already initialized (idempotent on devnet)
    const existing = await provider.connection.getAccountInfo(registryPda);
    if (existing) {
      const registry = await (program.account as any).registryState.fetch(registryPda);
      expect(registry.authority.toString()).to.equal(
        provider.wallet.publicKey.toString()
      );
      console.log("  Registry already initialized (skipped)");
      return;
    }

    const tx = await program.methods
      .initializeRegistry()
      .accountsPartial({
        registryState: registryPda,
        authority: provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .rpc({ commitment: "confirmed" });

    const registry = await (program.account as any).registryState.fetch(registryPda);
    expect(registry.authority.toString()).to.equal(
      provider.wallet.publicKey.toString()
    );

    console.log("  Registry initialized:", tx);
  });

  // ── Test: Initialize Computation Definitions ──────────────────────

  it("initializes computation definitions", async () => {
    // Fetch MXE account to get LUT offset slot dynamically
    const arcProgram = getArciumProgram(provider);
    const mxeData = await arcProgram.account.mxeAccount.fetch(mxeAccount);
    const lutOffsetSlot = mxeData.lutOffsetSlot as typeof anchor.BN.prototype;
    const addressLookupTable = getLookupTableAddress(
      program.programId,
      lutOffsetSlot
    );
    const lutProgram = anchor.web3.AddressLookupTableProgram.programId;

    const compDefShared = {
      mxeAccount,
      addressLookupTable,
      lutProgram,
      arciumProgram: arciumProgramId,
      systemProgram: anchor.web3.SystemProgram.programId,
    };

    // Init each comp def (skip if already exists)
    const circuits = [
      { name: "intersect_contacts", method: "initIntersectContactsCompDef" },
      { name: "register_user", method: "initRegisterUserCompDef" },
      { name: "reveal_registry_size", method: "initRevealRegistrySizeCompDef" },
    ];

    for (const circuit of circuits) {
      const offset = Buffer.from(
        getCompDefAccOffset(circuit.name)
      ).readUInt32LE();
      const compDefAddr = getCompDefAccAddress(program.programId, offset);
      const existing = await provider.connection.getAccountInfo(compDefAddr);
      if (existing) {
        console.log(`  ${circuit.name} comp def already initialized (skipped)`);
        continue;
      }
      // Retry with fresh blockhash on devnet timing issues
      for (let attempt = 0; attempt < 3; attempt++) {
        try {
          await (program.methods as any)
            [circuit.method]()
            .accountsPartial({
              payer: provider.wallet.publicKey,
              compDefAccount: compDefAddr,
              ...compDefShared,
            })
            .rpc({ commitment: "confirmed" });
          console.log(`  ${circuit.name} comp def initialized`);
          break;
        } catch (e: any) {
          if (attempt < 2 && e.message?.includes("Blockhash not found")) {
            console.log(`  ${circuit.name} blockhash expired, retrying (${attempt + 1}/3)...`);
            await new Promise((r) => setTimeout(r, 3000));
            continue;
          }
          throw e;
        }
      }
      // Brief delay between comp def inits to avoid devnet congestion
      await new Promise((r) => setTimeout(r, 1000));
    }

    console.log("  All computation definitions initialized");
  });

  // ── Test: Register a User ─────────────────────────────────────────

  it("registers a user in the global registry", async () => {
    // Setup crypto session
    const clientPrivateKey = x25519.utils.randomSecretKey();
    const clientPublicKey = x25519.getPublicKey(clientPrivateKey);
    const mxePublicKey = await fetchMXEKey(provider, program.programId);
    const sharedSecret = x25519.getSharedSecret(clientPrivateKey, mxePublicKey);
    const cipher = new RescueCipher(sharedSecret);
    const nonce = randomBytes(16);

    // Hash a test contact
    const testContact = "alice@example.com";
    const encoder = new TextEncoder();
    const hashBuffer = await crypto.subtle.digest(
      "SHA-256",
      encoder.encode(testContact)
    );
    const hashArray = new Uint8Array(hashBuffer);
    let contactHash = BigInt(0);
    for (let i = 0; i < 16; i++) {
      contactHash |= BigInt(hashArray[i]) << BigInt(i * 8);
    }

    // Encrypt
    const ciphertexts = cipher.encrypt([contactHash], nonce);
    const encryptedHash = Uint8Array.from(ciphertexts[0]);

    const computationOffset = new anchor.BN(randomBytes(8), "hex");

    const tx = await withRetry(() => program.methods
      .registerUser(
        computationOffset,
        Array.from(encryptedHash) as number[],
        Array.from(clientPublicKey) as number[],
        new anchor.BN(deserializeLE(nonce).toString())
      )
      .accountsPartial({
        user: provider.wallet.publicKey,
        registryState: registryPda,
        signPdaAccount: signPda,
        mxeAccount,
        mempoolAccount: getMempoolAccAddress(arciumEnv.arciumClusterOffset),
        executingPool: getExecutingPoolAccAddress(
          arciumEnv.arciumClusterOffset
        ),
        computationAccount: getComputationAccAddress(
          arciumEnv.arciumClusterOffset,
          computationOffset
        ),
        compDefAccount: getCompDefAccAddress(
          program.programId,
          Buffer.from(getCompDefAccOffset("register_user")).readUInt32LE()
        ),
        clusterAccount: getClusterAccAddress(arciumEnv.arciumClusterOffset),
        poolAccount: feePool,
        clockAccount,
        systemProgram: anchor.web3.SystemProgram.programId,
        arciumProgram: arciumProgramId,
      })
      .rpc({ commitment: "confirmed" }));

    // Wait for MXE computation
    await awaitComputationFinalization(
      provider,
      computationOffset,
      program.programId,
      "confirmed"
    );

    console.log("  User registered:", tx);
  });

  // ── Test: Private Set Intersection ────────────────────────────────

  it("performs private set intersection", async () => {
    // Setup fresh crypto session
    const clientPrivateKey = x25519.utils.randomSecretKey();
    const clientPublicKey = x25519.getPublicKey(clientPrivateKey);
    const mxePublicKey = await fetchMXEKey(provider, program.programId);
    const sharedSecret = x25519.getSharedSecret(clientPrivateKey, mxePublicKey);
    const cipher = new RescueCipher(sharedSecret);
    const nonce = randomBytes(16);

    // Create test contacts (one matching, rest non-matching)
    const testContacts = [
      "alice@example.com",  // registered above — should match
      "bob@unknown.com",    // not registered — should NOT match
      "charlie@test.org",   // not registered — should NOT match
    ];

    // Hash contacts
    const hashes: bigint[] = [];
    for (const contact of testContacts) {
      const encoder = new TextEncoder();
      const hashBuffer = await crypto.subtle.digest(
        "SHA-256",
        encoder.encode(contact)
      );
      const hashArray = new Uint8Array(hashBuffer);
      let h = BigInt(0);
      for (let i = 0; i < 16; i++) {
        h |= BigInt(hashArray[i]) << BigInt(i * 8);
      }
      hashes.push(h);
    }

    // Pad to MAX_CLIENT_CONTACTS
    const MAX_CLIENT_CONTACTS = 16;
    const paddedHashes = new Array(MAX_CLIENT_CONTACTS).fill(BigInt(0));
    hashes.forEach((h, i) => (paddedHashes[i] = h));

    // Encrypt all hashes + count
    const plaintextValues = [...paddedHashes, BigInt(testContacts.length)];
    const ciphertexts = cipher.encrypt(plaintextValues, nonce);

    const encryptedHashes = ciphertexts
      .slice(0, MAX_CLIENT_CONTACTS)
      .map((ct: number[]) => Array.from(Uint8Array.from(ct)));
    const encryptedCount = Array.from(
      Uint8Array.from(ciphertexts[MAX_CLIENT_CONTACTS])
    );

    const computationOffset = new anchor.BN(randomBytes(8), "hex");
    const SESSION_SEED = Buffer.from("psi_session");
    const [sessionPda] = anchor.web3.PublicKey.findProgramAddressSync(
      [
        SESSION_SEED,
        provider.wallet.publicKey.toBuffer(),
        computationOffset.toArrayLike(Buffer, "le", 8),
      ],
      program.programId
    );

    // Set up event listener
    const resultPromise = new Promise<any>((resolve) => {
      const listener = program.addEventListener(
        "psiCompleteEvent",
        (event: any) => {
          program.removeEventListener(listener as number);
          resolve(event);
        }
      );
    });

    // Submit PSI computation
    const tx = await withRetry(() => program.methods
      .intersectContacts(
        computationOffset,
        encryptedHashes,
        encryptedCount,
        Array.from(clientPublicKey) as number[],
        new anchor.BN(deserializeLE(nonce).toString())
      )
      .accountsPartial({
        user: provider.wallet.publicKey,
        psiSession: sessionPda,
        registryState: registryPda,
        signPdaAccount: signPda,
        mxeAccount,
        mempoolAccount: getMempoolAccAddress(arciumEnv.arciumClusterOffset),
        executingPool: getExecutingPoolAccAddress(
          arciumEnv.arciumClusterOffset
        ),
        computationAccount: getComputationAccAddress(
          arciumEnv.arciumClusterOffset,
          computationOffset
        ),
        compDefAccount: getCompDefAccAddress(
          program.programId,
          Buffer.from(
            getCompDefAccOffset("intersect_contacts")
          ).readUInt32LE()
        ),
        clusterAccount: getClusterAccAddress(arciumEnv.arciumClusterOffset),
        poolAccount: feePool,
        clockAccount,
        systemProgram: anchor.web3.SystemProgram.programId,
        arciumProgram: arciumProgramId,
      })
      .rpc({ commitment: "confirmed" }));

    console.log("  PSI computation submitted:", tx);

    // Await finalization
    await awaitComputationFinalization(
      provider,
      computationOffset,
      program.programId,
      "confirmed"
    );

    // Fetch and decrypt result
    const session = await (program.account as any).psiSession.fetch(sessionPda);
    expect(session.status).to.equal(2); // completed

    const decrypted = cipher.decrypt(
      session.resultCiphertext,
      session.resultNonce
    );

    // Verify: first contact (alice) should match, others should not
    expect(decrypted[0]).to.not.equal(BigInt(0)); // alice matched
    expect(decrypted[1]).to.equal(BigInt(0));      // bob not matched
    expect(decrypted[2]).to.equal(BigInt(0));      // charlie not matched

    const matchCount = Number(decrypted[MAX_CLIENT_CONTACTS]);
    expect(matchCount).to.equal(1);

    console.log("  PSI result: 1 match found (alice@example.com)");
  });

  // ── Test: Reveal Registry Size ──────────────────────────────────

  it("reveals registry size after registration", async () => {
    const computationOffset = new anchor.BN(randomBytes(8), "hex");

    // Listen for RegistrySizeEvent
    const sizePromise = new Promise<any>((resolve) => {
      const listener = program.addEventListener(
        "registrySizeEvent",
        (event: any) => {
          program.removeEventListener(listener as number);
          resolve(event);
        }
      );
    });

    const tx = await withRetry(() => program.methods
      .revealRegistrySize(computationOffset)
      .accountsPartial({
        payer: provider.wallet.publicKey,
        registryState: registryPda,
        signPdaAccount: signPda,
        mxeAccount,
        mempoolAccount: getMempoolAccAddress(arciumEnv.arciumClusterOffset),
        executingPool: getExecutingPoolAccAddress(
          arciumEnv.arciumClusterOffset
        ),
        computationAccount: getComputationAccAddress(
          arciumEnv.arciumClusterOffset,
          computationOffset
        ),
        compDefAccount: getCompDefAccAddress(
          program.programId,
          Buffer.from(
            getCompDefAccOffset("reveal_registry_size")
          ).readUInt32LE()
        ),
        clusterAccount: getClusterAccAddress(arciumEnv.arciumClusterOffset),
        poolAccount: feePool,
        clockAccount,
        systemProgram: anchor.web3.SystemProgram.programId,
        arciumProgram: arciumProgramId,
      })
      .rpc({ commitment: "confirmed" }));

    await awaitComputationFinalization(
      provider,
      computationOffset,
      program.programId,
      "confirmed"
    );

    const event = await sizePromise;
    // We registered 1 user (alice) in the previous test
    expect(event.totalUsers.toNumber()).to.be.greaterThanOrEqual(1);

    console.log("  Registry size:", event.totalUsers.toNumber(), "- tx:", tx);
  });

  // ── Test: PSI with Empty Contacts ───────────────────────────────

  it("returns zero matches for empty contact list", async () => {
    const clientPrivateKey = x25519.utils.randomSecretKey();
    const clientPublicKey = x25519.getPublicKey(clientPrivateKey);
    const mxePublicKey = await fetchMXEKey(provider, program.programId);
    const sharedSecret = x25519.getSharedSecret(clientPrivateKey, mxePublicKey);
    const cipher = new RescueCipher(sharedSecret);
    const nonce = randomBytes(16);

    // All zeros — no real contacts, count = 0
    const MAX_CLIENT_CONTACTS = 16;
    const paddedHashes = new Array(MAX_CLIENT_CONTACTS).fill(BigInt(0));

    const plaintextValues = [...paddedHashes, BigInt(0)];
    const ciphertexts = cipher.encrypt(plaintextValues, nonce);

    const encryptedHashes = ciphertexts
      .slice(0, MAX_CLIENT_CONTACTS)
      .map((ct: number[]) => Array.from(Uint8Array.from(ct)));
    const encryptedCount = Array.from(
      Uint8Array.from(ciphertexts[MAX_CLIENT_CONTACTS])
    );

    const computationOffset = new anchor.BN(randomBytes(8), "hex");
    const SESSION_SEED = Buffer.from("psi_session");
    const [sessionPda] = anchor.web3.PublicKey.findProgramAddressSync(
      [
        SESSION_SEED,
        provider.wallet.publicKey.toBuffer(),
        computationOffset.toArrayLike(Buffer, "le", 8),
      ],
      program.programId
    );

    const tx = await withRetry(() => program.methods
      .intersectContacts(
        computationOffset,
        encryptedHashes,
        encryptedCount,
        Array.from(clientPublicKey) as number[],
        new anchor.BN(deserializeLE(nonce).toString())
      )
      .accountsPartial({
        user: provider.wallet.publicKey,
        psiSession: sessionPda,
        registryState: registryPda,
        signPdaAccount: signPda,
        mxeAccount,
        mempoolAccount: getMempoolAccAddress(arciumEnv.arciumClusterOffset),
        executingPool: getExecutingPoolAccAddress(
          arciumEnv.arciumClusterOffset
        ),
        computationAccount: getComputationAccAddress(
          arciumEnv.arciumClusterOffset,
          computationOffset
        ),
        compDefAccount: getCompDefAccAddress(
          program.programId,
          Buffer.from(
            getCompDefAccOffset("intersect_contacts")
          ).readUInt32LE()
        ),
        clusterAccount: getClusterAccAddress(arciumEnv.arciumClusterOffset),
        poolAccount: feePool,
        clockAccount,
        systemProgram: anchor.web3.SystemProgram.programId,
        arciumProgram: arciumProgramId,
      })
      .rpc({ commitment: "confirmed" }));

    await awaitComputationFinalization(
      provider,
      computationOffset,
      program.programId,
      "confirmed"
    );

    const session = await (program.account as any).psiSession.fetch(sessionPda);
    expect(session.status).to.equal(2); // completed

    const decrypted = cipher.decrypt(
      session.resultCiphertext,
      session.resultNonce
    );

    const matchCount = Number(decrypted[MAX_CLIENT_CONTACTS]);
    expect(matchCount).to.equal(0);

    console.log("  Empty contacts: 0 matches (correct) - tx:", tx);
  });

  // ── Test: PSI with All Non-Matching Contacts ─────────────────────

  it("returns zero matches when no contacts are registered", async () => {
    const clientPrivateKey = x25519.utils.randomSecretKey();
    const clientPublicKey = x25519.getPublicKey(clientPrivateKey);
    const mxePublicKey = await fetchMXEKey(provider, program.programId);
    const sharedSecret = x25519.getSharedSecret(clientPrivateKey, mxePublicKey);
    const cipher = new RescueCipher(sharedSecret);
    const nonce = randomBytes(16);

    // All contacts are unregistered
    const testContacts = [
      "nobody1@fake.com",
      "nobody2@fake.com",
      "nobody3@fake.com",
      "nobody4@fake.com",
    ];

    const hashes: bigint[] = [];
    for (const contact of testContacts) {
      const encoder = new TextEncoder();
      const hashBuffer = await crypto.subtle.digest(
        "SHA-256",
        encoder.encode(contact)
      );
      const hashArray = new Uint8Array(hashBuffer);
      let h = BigInt(0);
      for (let i = 0; i < 16; i++) {
        h |= BigInt(hashArray[i]) << BigInt(i * 8);
      }
      hashes.push(h);
    }

    const MAX_CLIENT_CONTACTS = 16;
    const paddedHashes = new Array(MAX_CLIENT_CONTACTS).fill(BigInt(0));
    hashes.forEach((h, i) => (paddedHashes[i] = h));

    const plaintextValues = [...paddedHashes, BigInt(testContacts.length)];
    const ciphertexts = cipher.encrypt(plaintextValues, nonce);

    const encryptedHashes = ciphertexts
      .slice(0, MAX_CLIENT_CONTACTS)
      .map((ct: number[]) => Array.from(Uint8Array.from(ct)));
    const encryptedCount = Array.from(
      Uint8Array.from(ciphertexts[MAX_CLIENT_CONTACTS])
    );

    const computationOffset = new anchor.BN(randomBytes(8), "hex");
    const SESSION_SEED = Buffer.from("psi_session");
    const [sessionPda] = anchor.web3.PublicKey.findProgramAddressSync(
      [
        SESSION_SEED,
        provider.wallet.publicKey.toBuffer(),
        computationOffset.toArrayLike(Buffer, "le", 8),
      ],
      program.programId
    );

    const tx = await withRetry(() => program.methods
      .intersectContacts(
        computationOffset,
        encryptedHashes,
        encryptedCount,
        Array.from(clientPublicKey) as number[],
        new anchor.BN(deserializeLE(nonce).toString())
      )
      .accountsPartial({
        user: provider.wallet.publicKey,
        psiSession: sessionPda,
        registryState: registryPda,
        signPdaAccount: signPda,
        mxeAccount,
        mempoolAccount: getMempoolAccAddress(arciumEnv.arciumClusterOffset),
        executingPool: getExecutingPoolAccAddress(
          arciumEnv.arciumClusterOffset
        ),
        computationAccount: getComputationAccAddress(
          arciumEnv.arciumClusterOffset,
          computationOffset
        ),
        compDefAccount: getCompDefAccAddress(
          program.programId,
          Buffer.from(
            getCompDefAccOffset("intersect_contacts")
          ).readUInt32LE()
        ),
        clusterAccount: getClusterAccAddress(arciumEnv.arciumClusterOffset),
        poolAccount: feePool,
        clockAccount,
        systemProgram: anchor.web3.SystemProgram.programId,
        arciumProgram: arciumProgramId,
      })
      .rpc({ commitment: "confirmed" }));

    await awaitComputationFinalization(
      provider,
      computationOffset,
      program.programId,
      "confirmed"
    );

    const session = await (program.account as any).psiSession.fetch(sessionPda);
    expect(session.status).to.equal(2);

    const decrypted = cipher.decrypt(
      session.resultCiphertext,
      session.resultNonce
    );

    // All contacts should be non-matching
    for (let i = 0; i < testContacts.length; i++) {
      expect(decrypted[i]).to.equal(BigInt(0));
    }
    const matchCount = Number(decrypted[MAX_CLIENT_CONTACTS]);
    expect(matchCount).to.equal(0);

    console.log("  Non-matching contacts: 0 matches (correct) - tx:", tx);
  });

  // ── Test: PSI with Duplicate Contact in Query ──────────────────

  it("handles duplicate contacts in query correctly", async () => {
    const clientPrivateKey = x25519.utils.randomSecretKey();
    const clientPublicKey = x25519.getPublicKey(clientPrivateKey);
    const mxePublicKey = await fetchMXEKey(provider, program.programId);
    const sharedSecret = x25519.getSharedSecret(clientPrivateKey, mxePublicKey);
    const cipher = new RescueCipher(sharedSecret);
    const nonce = randomBytes(16);

    // Same registered contact repeated — each should match independently
    const testContacts = [
      "alice@example.com",  // registered — should match
      "alice@example.com",  // duplicate — should also match
      "charlie@test.org",   // not registered — should NOT match
    ];

    const hashes: bigint[] = [];
    for (const contact of testContacts) {
      const encoder = new TextEncoder();
      const hashBuffer = await crypto.subtle.digest(
        "SHA-256",
        encoder.encode(contact)
      );
      const hashArray = new Uint8Array(hashBuffer);
      let h = BigInt(0);
      for (let i = 0; i < 16; i++) {
        h |= BigInt(hashArray[i]) << BigInt(i * 8);
      }
      hashes.push(h);
    }

    const MAX_CLIENT_CONTACTS = 16;
    const paddedHashes = new Array(MAX_CLIENT_CONTACTS).fill(BigInt(0));
    hashes.forEach((h, i) => (paddedHashes[i] = h));

    const plaintextValues = [...paddedHashes, BigInt(testContacts.length)];
    const ciphertexts = cipher.encrypt(plaintextValues, nonce);

    const encryptedHashes = ciphertexts
      .slice(0, MAX_CLIENT_CONTACTS)
      .map((ct: number[]) => Array.from(Uint8Array.from(ct)));
    const encryptedCount = Array.from(
      Uint8Array.from(ciphertexts[MAX_CLIENT_CONTACTS])
    );

    const computationOffset = new anchor.BN(randomBytes(8), "hex");
    const SESSION_SEED = Buffer.from("psi_session");
    const [sessionPda] = anchor.web3.PublicKey.findProgramAddressSync(
      [
        SESSION_SEED,
        provider.wallet.publicKey.toBuffer(),
        computationOffset.toArrayLike(Buffer, "le", 8),
      ],
      program.programId
    );

    const tx = await withRetry(() => program.methods
      .intersectContacts(
        computationOffset,
        encryptedHashes,
        encryptedCount,
        Array.from(clientPublicKey) as number[],
        new anchor.BN(deserializeLE(nonce).toString())
      )
      .accountsPartial({
        user: provider.wallet.publicKey,
        psiSession: sessionPda,
        registryState: registryPda,
        signPdaAccount: signPda,
        mxeAccount,
        mempoolAccount: getMempoolAccAddress(arciumEnv.arciumClusterOffset),
        executingPool: getExecutingPoolAccAddress(
          arciumEnv.arciumClusterOffset
        ),
        computationAccount: getComputationAccAddress(
          arciumEnv.arciumClusterOffset,
          computationOffset
        ),
        compDefAccount: getCompDefAccAddress(
          program.programId,
          Buffer.from(
            getCompDefAccOffset("intersect_contacts")
          ).readUInt32LE()
        ),
        clusterAccount: getClusterAccAddress(arciumEnv.arciumClusterOffset),
        poolAccount: feePool,
        clockAccount,
        systemProgram: anchor.web3.SystemProgram.programId,
        arciumProgram: arciumProgramId,
      })
      .rpc({ commitment: "confirmed" }));

    await awaitComputationFinalization(
      provider,
      computationOffset,
      program.programId,
      "confirmed"
    );

    const session = await (program.account as any).psiSession.fetch(sessionPda);
    expect(session.status).to.equal(2);

    const decrypted = cipher.decrypt(
      session.resultCiphertext,
      session.resultNonce
    );

    // Both alice entries should match, charlie should not
    expect(decrypted[0]).to.not.equal(BigInt(0)); // alice matched
    expect(decrypted[1]).to.not.equal(BigInt(0)); // alice duplicate matched
    expect(decrypted[2]).to.equal(BigInt(0));      // charlie not matched

    console.log("  Duplicate contacts: both alice entries matched - tx:", tx);
  });

  // ── Test: Register Second User and Multi-Match PSI ──────────────

  it("registers a second user and finds multiple matches", async () => {
    // Register bob@unknown.com
    const clientPrivateKey = x25519.utils.randomSecretKey();
    const clientPublicKey = x25519.getPublicKey(clientPrivateKey);
    const mxePublicKey = await fetchMXEKey(provider, program.programId);
    const sharedSecret = x25519.getSharedSecret(clientPrivateKey, mxePublicKey);
    const cipher = new RescueCipher(sharedSecret);
    const nonce = randomBytes(16);

    const bobContact = "bob@unknown.com";
    const encoder = new TextEncoder();
    const hashBuffer = await crypto.subtle.digest(
      "SHA-256",
      encoder.encode(bobContact)
    );
    const hashArray = new Uint8Array(hashBuffer);
    let contactHash = BigInt(0);
    for (let i = 0; i < 16; i++) {
      contactHash |= BigInt(hashArray[i]) << BigInt(i * 8);
    }

    const regCiphertexts = cipher.encrypt([contactHash], nonce);
    const encryptedHash = Uint8Array.from(regCiphertexts[0]);
    const regOffset = new anchor.BN(randomBytes(8), "hex");

    await withRetry(() => program.methods
      .registerUser(
        regOffset,
        Array.from(encryptedHash) as number[],
        Array.from(clientPublicKey) as number[],
        new anchor.BN(deserializeLE(nonce).toString())
      )
      .accountsPartial({
        user: provider.wallet.publicKey,
        registryState: registryPda,
        signPdaAccount: signPda,
        mxeAccount,
        mempoolAccount: getMempoolAccAddress(arciumEnv.arciumClusterOffset),
        executingPool: getExecutingPoolAccAddress(
          arciumEnv.arciumClusterOffset
        ),
        computationAccount: getComputationAccAddress(
          arciumEnv.arciumClusterOffset,
          regOffset
        ),
        compDefAccount: getCompDefAccAddress(
          program.programId,
          Buffer.from(getCompDefAccOffset("register_user")).readUInt32LE()
        ),
        clusterAccount: getClusterAccAddress(arciumEnv.arciumClusterOffset),
        poolAccount: feePool,
        clockAccount,
        systemProgram: anchor.web3.SystemProgram.programId,
        arciumProgram: arciumProgramId,
      })
      .rpc({ commitment: "confirmed" }));

    await awaitComputationFinalization(
      provider,
      regOffset,
      program.programId,
      "confirmed"
    );

    console.log("  Bob registered");

    // Now intersect with both alice and bob — both should match
    const psiPrivKey = x25519.utils.randomSecretKey();
    const psiPubKey = x25519.getPublicKey(psiPrivKey);
    const psiShared = x25519.getSharedSecret(psiPrivKey, mxePublicKey);
    const psiCipher = new RescueCipher(psiShared);
    const psiNonce = randomBytes(16);

    const testContacts = [
      "alice@example.com",  // registered — should match
      "bob@unknown.com",    // now registered — should match
      "charlie@test.org",   // not registered — should NOT match
    ];

    const hashes: bigint[] = [];
    for (const contact of testContacts) {
      const enc = new TextEncoder();
      const buf = await crypto.subtle.digest("SHA-256", enc.encode(contact));
      const arr = new Uint8Array(buf);
      let h = BigInt(0);
      for (let i = 0; i < 16; i++) {
        h |= BigInt(arr[i]) << BigInt(i * 8);
      }
      hashes.push(h);
    }

    const MAX_CLIENT_CONTACTS = 16;
    const paddedHashes = new Array(MAX_CLIENT_CONTACTS).fill(BigInt(0));
    hashes.forEach((h, i) => (paddedHashes[i] = h));

    const plaintextValues = [...paddedHashes, BigInt(testContacts.length)];
    const psiCts = psiCipher.encrypt(plaintextValues, psiNonce);

    const encHashes = psiCts
      .slice(0, MAX_CLIENT_CONTACTS)
      .map((ct: number[]) => Array.from(Uint8Array.from(ct)));
    const encCount = Array.from(
      Uint8Array.from(psiCts[MAX_CLIENT_CONTACTS])
    );

    const psiOffset = new anchor.BN(randomBytes(8), "hex");
    const SESSION_SEED = Buffer.from("psi_session");
    const [sessionPda] = anchor.web3.PublicKey.findProgramAddressSync(
      [
        SESSION_SEED,
        provider.wallet.publicKey.toBuffer(),
        psiOffset.toArrayLike(Buffer, "le", 8),
      ],
      program.programId
    );

    await withRetry(() => program.methods
      .intersectContacts(
        psiOffset,
        encHashes,
        encCount,
        Array.from(psiPubKey) as number[],
        new anchor.BN(deserializeLE(psiNonce).toString())
      )
      .accountsPartial({
        user: provider.wallet.publicKey,
        psiSession: sessionPda,
        registryState: registryPda,
        signPdaAccount: signPda,
        mxeAccount,
        mempoolAccount: getMempoolAccAddress(arciumEnv.arciumClusterOffset),
        executingPool: getExecutingPoolAccAddress(
          arciumEnv.arciumClusterOffset
        ),
        computationAccount: getComputationAccAddress(
          arciumEnv.arciumClusterOffset,
          psiOffset
        ),
        compDefAccount: getCompDefAccAddress(
          program.programId,
          Buffer.from(
            getCompDefAccOffset("intersect_contacts")
          ).readUInt32LE()
        ),
        clusterAccount: getClusterAccAddress(arciumEnv.arciumClusterOffset),
        poolAccount: feePool,
        clockAccount,
        systemProgram: anchor.web3.SystemProgram.programId,
        arciumProgram: arciumProgramId,
      })
      .rpc({ commitment: "confirmed" }));

    await awaitComputationFinalization(
      provider,
      psiOffset,
      program.programId,
      "confirmed"
    );

    const session = await (program.account as any).psiSession.fetch(sessionPda);
    expect(session.status).to.equal(2);

    const decrypted = psiCipher.decrypt(
      session.resultCiphertext,
      session.resultNonce
    );

    // alice and bob should both match, charlie should not
    expect(decrypted[0]).to.not.equal(BigInt(0)); // alice matched
    expect(decrypted[1]).to.not.equal(BigInt(0)); // bob matched
    expect(decrypted[2]).to.equal(BigInt(0));      // charlie not matched

    const matchCount = Number(decrypted[MAX_CLIENT_CONTACTS]);
    expect(matchCount).to.equal(2);

    console.log("  Multi-match PSI: 2 matches found (alice, bob)");
  });
});
